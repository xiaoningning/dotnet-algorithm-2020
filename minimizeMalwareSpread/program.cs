public class Solution {
    public int MinMalwareSpread1(int[][] graph, int[] initial) {
        int mn = Int32.MaxValue, res = 0;
        var infected = new List<int>(initial);
        foreach (int n in infected) {
            var tl = new List<int>(infected);
            tl.Remove(n);
            // cnt of infected check min infected
            // after removint n
            int cnt = Helper(graph, tl);
            if (cnt < mn || (cnt == mn && n < res)) {
                mn = cnt;
                res = n;
            }
        }
        // O(n^3)
        return res;
    }
    int Helper(int[][] graph, List<int> infected) {
        var q = new Queue<int>();
        foreach (int num in infected) q.Enqueue(num);
        while (q.Any()) {
            var t = q.Dequeue();
            for (int i = 0; i < graph[t].Length; ++i) {
                if (graph[t][i] != 1 || infected.Contains(i)) continue;
                infected.Add(i);
                q.Enqueue(i);
            }
        }
        return infected.Count;
    }
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length, mn = Int32.MaxValue, res = 0;
        int[] root = new int[n], area = new int[n], malware = new int[n];
        for (int i = 0; i < n; ++i) root[i] = i;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) root[findRoot(root, i)] = findRoot(root, j);
            }
        }
        for (int i = 0; i < n; ++i) ++area[findRoot(root, i)];
        // check if the root of malware
        foreach (int i in initial) ++malware[findRoot(root, i)];
        // smaller i for malware node
        foreach (int i in initial) {
            // max infected => -area is min
            int cnt = malware[findRoot(root, i)] == 1 ? -area[findRoot(root, i)] : 0;
            if (cnt < mn || (cnt == mn && i < res)) {
                mn = cnt;
                res = i;
            }
        }
        // O(n^2) Union Find
        return res;
    }
    int findRoot(int[] root, int i) {
        return i == root[i] ? i : findRoot(root, root[i]);
    }
}
